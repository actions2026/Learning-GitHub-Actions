name: CI Pipleine using Resuable Workflow.
on:
  pull_request:
    branches:
      - main

permissions:
  actions: read
  security-events: write
  packages: write
  contents: read

env:
  OCI_REGISTRY: ghcr.io
  OCI_REPOSITORY: ${{ github.repository_owner }}/helm-charts

jobs:
  ci-pipleine-job:
    uses: actions2026/reusable-workflows/.github/workflows/ci-pipeline.yml@main #location of the reusable workflow. Org/repo/worflow path@branch
    with: #used to set arguments, like in actions
      run_codeql: true
      run_sonarqube: true
      run_build: true
      run_ghcr_publish: true
    secrets: 
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }} #passing the secret to the reusable workflow. This allows the reusable workflow to access the secret and use it for authentication when interacting with SonarCloud.
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }} #passing the secret to the reusable workflow. This allows the reusable workflow to access the secret and use it for authentication when interacting with DockerHub.
      DOCKERHUB_ACCESS_TOKEN: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }} #passing the secret to the reusable workflow. This allows the reusable workflow to access the secret and use it for authentication when interacting with DockerHub.
  
  deploy_with_kubectl:
    needs: ci-pipleine-job
    uses: actions2026/reusable-workflows/.github/workflows/deploy-with-kubectl.yml@main #location of the reusable workflow. Org/repo/worflow path@branch
    with: #inputs needed
      ENVIRONMENT: STAGING
      IMAGE_NAME: ghcr.io/actions2026/thinknyx_app

    secrets:
      KUBECONFIG: ${{ secrets.KUBECONFIG }} #passing the secret to the reusable workflow. This allows the reusable workflow to access the secret and use it for authentication when interacting with Kubernetes cluster.

  run-selenium-tests:

    needs: deploy_with_kubectl
    uses: actions2026/reusable-workflows/.github/workflows/run-selenium-tests.yml@main #location of the reusable workflow. Org/repo/worflow path@branch
    with:
      ENVIRONMENT: STAGING

  publish-helm-chart:
    needs: run-selenium-tests
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v5

    - name: Set up Helm
      uses: azure/setup-helm@v3

      with:
        version: v3.12.0

    - name: Install yq
      run: |
        sudo curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
        sudo chmod +x /usr/local/bin/yq

    - name: Check Helm Version
      run: |
        helm version
        yq --version

    - name: update image name in Chart & values.yaml #env variable created in shell is not automatically available in next steps because GHA uses a new shell for each step. 
      run: |
        export IMAGE_TAGS="${{ github.run_id }}-${GITHUB_SHA::7}" 
        export VERSION="0.1.0-${IMAGE_TAGS}"
        yq e -i '.image.tag = strenv(IMAGE_TAGS)' charts/values.yaml
        yq e -i '.appVersion = strenv(IMAGE_TAGS)' charts/Chart.yaml
        yq e -i '.version = strenv(VERSION)' charts/Chart.yaml        
        cat charts/values.yaml
        cat charts/Chart.yaml
        

    - name: Lint Chart  #lint is a helm command that checks the chart for any issues or errors
      run: helm lint charts/

    - name: Package Helm Chart #package is a helm command that creates a .tgz file of the chart, using the folder. It names the .tgz packaged file with the name and version found in Chart.yaml. The package can be used for deployment or distribution
      run: |
        helm package charts/
        ls -ltr .

    - name: Login to GHCR
      run: |
        echo ${{ secrets.GITHUB_TOKEN }} | helm registry login ${{ env.OCI_REGISTRY }} -u ${{ github.actor }} --password-stdin

    - name: Push Helm Chart to GHCR
      run: |
        export IMAGE_TAGS="${{ github.run_id }}-${GITHUB_SHA::7}"
        export VERSION="0.1.0-${IMAGE_TAGS}"
        helm push thinknyxapp-${VERSION}.tgz oci://${{ env.OCI_REGISTRY }}/${{ env.OCI_REPOSITORY }}

    - name: Logout from GHCR
      run: helm registry logout ${{ env.OCI_REGISTRY }}



#       #     name: Deploy with kubectl
# #     runs-on: github-actions-scaleset-demo
# #     needs: ci-pipleine-job
# #     steps:
# #     - name: Checkout Repository
# #       uses: actions/checkout@v3

# #     - name: Install kubectl
# #       run: |
# #         curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
# #         chmod +x ./kubectl
# #         sudo mv ./kubectl /usr/local/bin/kubectl
# #         kubectl version --client
# #     - name: Configure kubectl
# #       run: |
# #         mkdir -p $HOME/.kube
# #         echo "${{ secrets.KUBECONFIG }}" > $HOME/.kube/config
# #         kubectl version
# #         kubectl get nodes

# #     - name: Install yq
# #       run: |
# #         sudo curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
# #         sudo chmod +x /usr/local/bin/yq
# #         yq --version

# #     - name: update image name in deployment YAML
# #       run: |
# #         IMAGE_TAGS="${{ github.run_id }}-${GITHUB_SHA::7}"
# #         export IMAGE="ghcr.io/actions2026/thinknyx_app:${IMAGE_TAGS}"
# #         yq e -i '.spec.template.spec.containers[0].image = strenv(IMAGE)' manifests/deployment.yaml  
# #         cat manifests/deployment.yaml
# # ####uses yaml query to filter and edit/replace field value in manifests/deployment.yaml file with "IMAGE" env variable created